# 新增服务开发指南

本文档详细说明了在 Micro Temp 项目中新增一个微服务的完整流程。

## 目录

1. [快速开始](#快速开始)
2. [详细步骤](#详细步骤)
3. [示例：新增鸽子档案服务](#示例新增鸽子档案服务)
4. [常见问题](#常见问题)

## 快速开始

新增服务的基本流程：

```bash
# 1. 定义 API
创建 api/proto/{service}/v1/{service}.proto

# 2. 生成代码
make proto

# 3. 创建数据库表
make migrate/create name=create_{table}_table
make migrate/up

# 4. 定义 SQL 查询
创建 internal/service/{service}/queries/{service}.sql

# 5. 生成数据库代码
make sqlc

# 6. 实现业务逻辑
实现 store.go, service.go, connect.go

# 7. 运行服务
make run/{service}-service
```

## 详细步骤

### 步骤 1：定义 Proto API

在 `api/proto/` 目录下创建新服务的 proto 定义：

```bash
mkdir -p api/proto/{service}/v1
touch api/proto/{service}/v1/{service}.proto
```

Proto 文件基本结构：

```protobuf
syntax = "proto3";

package {service}.v1;

option go_package = "micro-holtye/gen/{service}/v1;{service}v1";

import "google/protobuf/timestamp.proto";

service {Service}Service {
  rpc Create{Entity}(Create{Entity}Request) returns (Create{Entity}Response);
  rpc Get{Entity}(Get{Entity}Request) returns (Get{Entity}Response);
  rpc Update{Entity}(Update{Entity}Request) returns (Update{Entity}Response);
  rpc Delete{Entity}(Delete{Entity}Request) returns (Delete{Entity}Response);
  rpc List{Entities}(List{Entities}Request) returns (List{Entities}Response);
}

message {Entity} {
  string id = 1;
  // ... 其他字段
  google.protobuf.Timestamp created_at = 10;
  google.protobuf.Timestamp updated_at = 11;
}
```

### 步骤 2：生成 Proto 代码

运行命令生成 Connect RPC 代码：

```bash
make proto
```

生成的代码位置：`gen/{service}/v1/`

### 步骤 3：创建数据库迁移

#### 3.1 创建迁移文件

```bash
make migrate/create name=create_{table}_table
```

#### 3.2 编辑迁移文件

上迁移文件 `migrations/00000X_create_{table}_table.up.sql`：

```sql
CREATE TABLE IF NOT EXISTS {table} (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    -- 其他字段
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_{table}_created_at ON {table}(created_at);

-- 创建更新时间触发器
CREATE TRIGGER update_{table}_updated_at
    BEFORE UPDATE ON {table}
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

下迁移文件 `migrations/00000X_create_{table}_table.down.sql`：

```sql
DROP TRIGGER IF EXISTS update_{table}_updated_at ON {table};
DROP TABLE IF EXISTS {table};
```

#### 3.3 应用迁移

```bash
export DATABASE_URL="postgres://pigeon:pigeon123@localhost:5432/pigeon_db?sslmode=disable"
make migrate/up
```

### 步骤 4：定义 SQL 查询

创建查询文件：

```bash
mkdir -p internal/service/{service}/queries
touch internal/service/{service}/queries/{entities}.sql
```

示例查询文件：

```sql
-- name: Create{Entity} :one
INSERT INTO {table} (
    field1, field2, field3
) VALUES (
    $1, $2, $3
)
RETURNING *;

-- name: Get{Entity} :one
SELECT * FROM {table}
WHERE id = $1;

-- name: List{Entities} :many
SELECT * FROM {table}
ORDER BY created_at DESC
LIMIT $1 OFFSET $2;

-- name: Update{Entity} :one
UPDATE {table}
SET 
    field1 = COALESCE($2, field1),
    field2 = COALESCE($3, field2),
    updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: Delete{Entity} :exec
DELETE FROM {table}
WHERE id = $1;
```

### 步骤 5：配置 sqlc

在 `sqlc.yaml` 中添加新服务配置：

```yaml
- engine: "postgresql"
  queries: "internal/service/{service}/queries"
  schema: "migrations"
  gen:
    go:
      package: "{service}db"
      out: "internal/service/{service}/db"
      sql_package: "database/sql"
      emit_json_tags: true
      emit_interface: true
      emit_empty_slices: true
      emit_result_struct_pointers: true
      overrides:
        - db_type: "timestamptz"
          go_type: "time.Time"
        - db_type: "uuid"
          go_type: "github.com/google/uuid.UUID"
```

生成数据库代码：

```bash
make sqlc
```

### 步骤 6：实现服务层

#### 6.1 Store 层 (`internal/service/{service}/store.go`)

```go
package {service}

import (
    "context"
    "database/sql"
    "{service}db" "micro-holtye/internal/service/{service}/db"
)

type Store struct {
    db      *sql.DB
    queries {service}db.Querier
}

func NewStore(db *sql.DB) *Store {
    return &Store{
        db:      db,
        queries: {service}db.New(db),
    }
}

// 实现数据访问方法
```

#### 6.2 Service 层 (`internal/service/{service}/service.go`)

```go
package {service}

import (
    "context"
)

type Service struct {
    store *Store
}

func NewService(store *Store) *Service {
    return &Service{
        store: store,
    }
}

// 实现业务逻辑方法
```

#### 6.3 Connect Handler (`internal/service/{service}/connect.go`)

```go
package {service}

import (
    "context"
    "connectrpc.com/connect"
    {service}v1 "micro-holtye/gen/{service}/v1"
    "{service}v1connect" "micro-holtye/gen/{service}/v1/{service}v1connect"
)

type ConnectHandler struct {
    service *Service
}

func NewConnectHandler(service *Service) {service}v1connect.{Service}ServiceHandler {
    return &ConnectHandler{
        service: service,
    }
}

// 实现 RPC 方法
```

### 步骤 7：创建服务入口

创建 `cmd/{service}-service/main.go`：

```go
package main

import (
    "database/sql"
    "log"
    "net/http"
    
    _ "github.com/lib/pq"
    "micro-holtye/internal/pkg/config"
    "micro-holtye/internal/service/{service}"
    "{service}v1connect" "micro-holtye/gen/{service}/v1/{service}v1connect"
)

func main() {
    // 加载配置
    cfg := config.Load("configs/{service}.yaml")
    
    // 连接数据库
    db, err := sql.Open("postgres", cfg.DatabaseURL)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // 初始化服务
    store := {service}.NewStore(db)
    service := {service}.NewService(store)
    handler := {service}.NewConnectHandler(service)
    
    // 启动 HTTP 服务
    mux := http.NewServeMux()
    path, handler := {service}v1connect.New{Service}ServiceHandler(handler)
    mux.Handle(path, handler)
    
    log.Printf("Starting {service} service on %s", cfg.ServerAddress)
    if err := http.ListenAndServe(cfg.ServerAddress, mux); err != nil {
        log.Fatal(err)
    }
}
```

### 步骤 8：添加配置文件

创建 `configs/{service}.yaml`：

```yaml
server:
  address: ":8082"

database:
  url: "postgres://pigeon:pigeon123@localhost:5432/pigeon_db?sslmode=disable"
  max_connections: 25
  max_idle_connections: 5

redis:
  address: "localhost:6379"
  password: ""
  db: 0

log:
  level: "info"
  format: "json"
```

### 步骤 9：更新 Makefile

在 `Makefile` 中添加新服务的构建和运行命令：

```makefile
.PHONY: build
build: proto
	go build -o bin/user-service ./cmd/user-service
	go build -o bin/order-service ./cmd/order-service
	go build -o bin/{service}-service ./cmd/{service}-service  # 新增

.PHONY: run/{service}-service
run/{service}-service:
	go run ./cmd/{service}-service
```

### 步骤 10：测试和验证

```bash
# 运行测试
make test

# 代码检查
make lint

# 启动服务
make run/{service}-service
```

## 示例：新增鸽子档案服务

以下是新增"鸽子档案服务"的具体示例：

### 1. Proto 定义

`api/proto/pigeon/v1/pigeon.proto`:

```protobuf
syntax = "proto3";

package pigeon.v1;

option go_package = "micro-holtye/gen/pigeon/v1;pigeonv1";

import "google/protobuf/timestamp.proto";

service Tempervice {
  rpc CreatePigeonProfile(CreatePigeonProfileRequest) returns (CreatePigeonProfileResponse);
  rpc GetPigeonProfile(GetPigeonProfileRequest) returns (GetPigeonProfileResponse);
  rpc UpdatePigeonProfile(UpdatePigeonProfileRequest) returns (UpdatePigeonProfileResponse);
  rpc ListPigeonProfiles(ListPigeonProfilesRequest) returns (ListPigeonProfilesResponse);
}

message PigeonProfile {
  string id = 1;
  string ring_number = 2;  // 鸽环号
  string name = 3;
  string breed = 4;         // 品种
  string color = 5;         // 羽色
  string gender = 6;        // 性别
  string birth_date = 7;    // 出生日期
  string owner_id = 8;      // 所属用户ID
  google.protobuf.Timestamp created_at = 9;
  google.protobuf.Timestamp updated_at = 10;
}
```

### 2. 数据库表设计

```sql
CREATE TABLE IF NOT EXISTS pigeon_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ring_number VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    breed VARCHAR(50),
    color VARCHAR(50),
    gender VARCHAR(10) CHECK (gender IN ('male', 'female', 'unknown')),
    birth_date DATE,
    owner_id UUID NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    FOREIGN KEY (owner_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_pigeon_profiles_owner_id ON pigeon_profiles(owner_id);
CREATE INDEX idx_pigeon_profiles_ring_number ON pigeon_profiles(ring_number);
```

### 3. SQL 查询示例

```sql
-- name: CreatePigeonProfile :one
INSERT INTO pigeon_profiles (
    ring_number, name, breed, color, gender, birth_date, owner_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING *;

-- name: GetPigeonProfileByID :one
SELECT * FROM pigeon_profiles
WHERE id = $1;

-- name: ListPigeonProfilesByOwner :many
SELECT * FROM pigeon_profiles
WHERE owner_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3;
```

## 常见问题

### Q: 如何处理服务间调用？

A: 在需要调用其他服务的地方，创建 Connect 客户端：

```go
import (
    "connectrpc.com/connect"
    userv1 "micro-holtye/gen/user/v1"
    "micro-holtye/gen/user/v1/userv1connect"
)

// 创建客户端
client := userv1connect.NewUserServiceClient(
    http.DefaultClient,
    "http://localhost:8080",
)

// 调用服务
resp, err := client.GetUser(ctx, connect.NewRequest(&userv1.GetUserRequest{
    Id: userID,
}))
```

### Q: 如何添加认证和授权？

A: 使用 Connect 拦截器（Interceptor）：

```go
func AuthInterceptor() connect.UnaryInterceptorFunc {
    return func(next connect.UnaryFunc) connect.UnaryFunc {
        return func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {
            // 验证 token
            token := req.Header().Get("Authorization")
            if token == "" {
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("missing token"))
            }
            // 继续处理
            return next(ctx, req)
        }
    }
}
```

### Q: 如何处理事务？

A: 在 Service 层使用数据库事务：

```go
func (s *Service) CreateWithTransaction(ctx context.Context) error {
    tx, err := s.store.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()
    
    // 执行多个数据库操作
    qtx := s.store.queries.WithTx(tx)
    // ...
    
    return tx.Commit()
}
```

### Q: 如何添加缓存？

A: 在 Store 层集成 Redis：

```go
import "github.com/redis/go-redis/v9"

type Store struct {
    db      *sql.DB
    queries pigeondb.Querier
    cache   *redis.Client
}

func (s *Store) GetWithCache(ctx context.Context, id string) (*PigeonProfile, error) {
    // 先查缓存
    cached, err := s.cache.Get(ctx, "pigeon:"+id).Result()
    if err == nil {
        // 解析并返回缓存数据
    }
    
    // 缓存未命中，查询数据库
    profile, err := s.queries.GetPigeonProfile(ctx, id)
    if err != nil {
        return nil, err
    }
    
    // 写入缓存
    s.cache.Set(ctx, "pigeon:"+id, profile, time.Hour)
    return profile, nil
}
```

## 相关文档

- [项目架构说明](./项目架构说明.md)
- [Connect 框架文档](https://connectrpc.com/docs/go/getting-started)
- [sqlc 文档](https://docs.sqlc.dev/)
- [Protocol Buffers 文档](https://protobuf.dev/)