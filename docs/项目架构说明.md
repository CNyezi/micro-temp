# Micro Temp 项目架构说明

## 项目概述

Micro Temp 是一个基于 Go 语言的微服务架构项目，使用 Connect RPC 框架（gRPC 兼容）构建服务间通信，采用 Protocol Buffers 定义 API 接口，使用 sqlc 生成类型安全的数据库代码。

## 技术栈

### 核心技术

- **语言**: Go 1.21+
- **RPC 框架**: [Connect](https://connectrpc.com/) - 现代化的 RPC 框架，兼容 gRPC
- **API 定义**: Protocol Buffers v3
- **代码生成**: 
  - [Buf](https://buf.build/) - Protocol Buffer 工具链
  - [sqlc](https://sqlc.dev/) - SQL 到 Go 代码生成器
- **数据库**: PostgreSQL 15
- **缓存**: Redis 7
- **数据库迁移**: [golang-migrate](https://github.com/golang-migrate/migrate)

### 开发工具

- **代码检查**: golangci-lint
- **容器化**: Docker & Docker Compose
- **构建工具**: Make

## 项目结构

```
micro-holtye/
├── api/                    # API 定义
│   └── proto/              # Protocol Buffer 文件
│       ├── user/v1/        # 用户服务 API
│       └── order/v1/       # 订单服务 API
│
├── cmd/                    # 服务入口
│   ├── user-service/       # 用户服务
│   └── order-service/      # 订单服务
│
├── configs/                # 配置文件
│   ├── user.yaml          # 用户服务配置
│   └── order.yaml         # 订单服务配置
│
├── docs/                   # 项目文档
│   ├── 新增服务开发指南.md
│   └── 项目架构说明.md
│
├── gen/                    # 生成的代码（自动生成，不要手动修改）
│   ├── user/v1/           # 用户服务生成代码
│   └── order/v1/          # 订单服务生成代码
│
├── internal/               # 内部代码
│   ├── pkg/               # 共享包
│   │   ├── config/        # 配置管理
│   │   ├── database/      # 数据库连接
│   │   ├── logger/        # 日志工具
│   │   └── middleware/    # 中间件
│   │
│   └── service/           # 服务实现
│       ├── user/          # 用户服务
│       │   ├── connect.go # Connect RPC 处理器
│       │   ├── service.go # 业务逻辑
│       │   ├── store.go   # 数据访问层
│       │   ├── db/        # sqlc 生成的代码
│       │   └── queries/   # SQL 查询定义
│       │
│       └── order/         # 订单服务（结构同上）
│
├── migrations/             # 数据库迁移文件
├── buf.gen.yaml           # Buf 代码生成配置
├── buf.yaml               # Buf 配置
├── sqlc.yaml              # sqlc 配置
├── Makefile               # 构建脚本
├── go.mod                 # Go 模块定义
└── CLAUDE.md              # AI 助手指南
```

## 架构设计

### 分层架构

每个微服务采用清晰的分层架构：

```
┌─────────────────────────────────────┐
│         Connect Handler             │  ← RPC 接口层
├─────────────────────────────────────┤
│         Service Layer               │  ← 业务逻辑层
├─────────────────────────────────────┤
│          Store Layer                │  ← 数据访问层
├─────────────────────────────────────┤
│        Database (sqlc)              │  ← 数据持久层
└─────────────────────────────────────┘
```

#### 1. Connect Handler 层
- **职责**: 处理 RPC 请求和响应
- **位置**: `internal/service/{service}/connect.go`
- **功能**:
  - 实现 Proto 定义的服务接口
  - 请求参数验证
  - 错误码转换
  - 调用 Service 层

#### 2. Service 层
- **职责**: 实现核心业务逻辑
- **位置**: `internal/service/{service}/service.go`
- **功能**:
  - 业务规则实现
  - 事务管理
  - 跨服务调用协调
  - 业务级别的验证

#### 3. Store 层
- **职责**: 数据访问抽象
- **位置**: `internal/service/{service}/store.go`
- **功能**:
  - 封装数据库操作
  - 缓存管理（Redis）
  - 数据转换
  - 查询优化

#### 4. Database 层
- **职责**: 数据持久化
- **位置**: `internal/service/{service}/db/`
- **功能**:
  - sqlc 生成的类型安全代码
  - SQL 查询执行
  - 数据库连接管理

### 服务通信

```
┌──────────┐     Connect RPC      ┌──────────┐
│  Client  │ ◄─────────────────► │  Service │
└──────────┘                      └──────────┘
     │                                  │
     │          HTTP/2 + Proto          │
     └──────────────────────────────────┘
```

服务间通信特点：
- 基于 HTTP/2 的高性能通信
- Protocol Buffers 序列化
- 支持流式传输
- 自动生成客户端和服务端代码

### 数据流

```
Client Request
     ↓
Connect Handler (请求解析)
     ↓
Service Layer (业务处理)
     ↓
Store Layer (数据访问)
     ↓
Database/Cache
     ↓
Response
```

## 核心组件说明

### Protocol Buffers 定义

所有服务接口通过 `.proto` 文件定义：

```protobuf
service UserService {
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
}
```

优势：
- 强类型接口定义
- 自动生成客户端和服务端代码
- 向后兼容的版本管理
- 跨语言支持

### Connect RPC 框架

Connect 是一个现代化的 RPC 框架：

- **兼容性**: 完全兼容 gRPC 协议
- **简单性**: 基于 HTTP 语义，易于调试
- **性能**: 支持 HTTP/2 和流式传输
- **生态**: 丰富的中间件支持

### sqlc 代码生成

通过 SQL 查询自动生成 Go 代码：

```sql
-- name: GetUser :one
SELECT * FROM users WHERE id = $1;
```

生成的 Go 代码：
```go
func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (*User, error)
```

优势：
- 类型安全的数据库操作
- 编译时 SQL 验证
- 无运行时反射，高性能
- SQL 和 Go 代码分离

## 配置管理

### 配置文件结构

```yaml
server:
  address: ":8080"
  
database:
  url: "postgres://..."
  max_connections: 25
  
redis:
  address: "localhost:6379"
  
log:
  level: "info"
  format: "json"
```

### 环境变量

支持通过环境变量覆盖配置：

- `DATABASE_URL` - 数据库连接字符串
- `REDIS_URL` - Redis 连接字符串
- `LOG_LEVEL` - 日志级别
- `SERVER_PORT` - 服务端口

## 开发工作流

### 1. API 驱动开发

```
定义 Proto → 生成代码 → 实现业务逻辑 → 测试
```

### 2. 数据库驱动开发

```
设计表结构 → 创建迁移 → 编写 SQL → 生成代码 → 实现数据访问
```

### 3. 测试驱动开发

```
编写测试 → 实现功能 → 重构 → 验证
```

## 部署架构

### 开发环境

```
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   User      │  │   Order     │  │   Gateway   │
│  Service    │  │  Service    │  │   Service   │
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
       │                │                 │
       └────────────────┼─────────────────┘
                        │
                ┌───────▼────────┐
                │   PostgreSQL   │
                │    + Redis     │
                └────────────────┘
```

### 生产环境建议

```
┌──────────────┐
│ Load Balancer│
└──────┬───────┘
       │
┌──────▼───────────────────────────┐
│         Kubernetes Cluster        │
│  ┌─────────┐  ┌─────────┐       │
│  │Service A│  │Service B│  ...  │
│  └─────────┘  └─────────┘       │
│                                  │
│  ┌──────────────────────────┐   │
│  │    Service Mesh (Istio)  │   │
│  └──────────────────────────┘   │
└──────────────────────────────────┘
       │
┌──────▼───────────────────────────┐
│  Database Cluster (PostgreSQL)   │
│  Cache Layer (Redis Cluster)     │
└──────────────────────────────────┘
```

## 监控和可观测性

### 日志

- 结构化日志（JSON 格式）
- 日志级别：DEBUG, INFO, WARN, ERROR
- 请求追踪 ID
- 性能指标记录

### 监控指标

建议集成的监控：

- **Prometheus**: 指标收集
- **Grafana**: 可视化面板
- **Jaeger**: 分布式追踪
- **ELK Stack**: 日志聚合分析

### 健康检查

每个服务应提供：

- `/health` - 基础健康检查
- `/ready` - 就绪状态检查
- `/metrics` - Prometheus 指标

## 安全考虑

### 认证和授权

- JWT Token 认证
- RBAC 权限控制
- API Key 管理
- OAuth2 集成（可选）

### 数据安全

- 敏感数据加密存储
- TLS/SSL 传输加密
- SQL 注入防护（sqlc 自动处理）
- 输入验证和清理

### 密钥管理

- 使用环境变量或密钥管理服务
- 定期轮换密钥
- 避免在代码中硬编码密钥

## 最佳实践

### 代码规范

1. **命名规范**: 遵循 Go 语言规范
2. **错误处理**: 明确的错误类型和消息
3. **测试覆盖**: 单元测试覆盖率 > 80%
4. **代码审查**: PR 需要至少一人审查

### 服务设计

1. **单一职责**: 每个服务专注一个业务领域
2. **接口优先**: 先定义 Proto，再实现
3. **幂等性**: 支持请求重试
4. **优雅关闭**: 处理 SIGTERM 信号

### 数据库设计

1. **规范化**: 适度的数据库规范化
2. **索引优化**: 基于查询模式创建索引
3. **迁移管理**: 所有变更通过迁移脚本
4. **备份策略**: 定期备份和恢复测试

## 故障处理

### 熔断器模式

```go
// 使用熔断器防止级联故障
breaker := circuit.NewBreaker()
result, err := breaker.Execute(func() (interface{}, error) {
    return callService()
})
```

### 重试策略

```go
// 指数退避重试
retry.Do(
    func() error { return callService() },
    retry.Attempts(3),
    retry.Delay(time.Second),
    retry.DelayType(retry.BackOffDelay),
)
```

### 降级策略

- 缓存降级
- 默认值降级
- 限流降级

## 性能优化

### 数据库优化

- 连接池配置
- 查询优化
- 批量操作
- 读写分离

### 缓存策略

- 多级缓存
- 缓存预热
- 缓存更新策略
- 缓存穿透防护

### 并发控制

- 协程池
- 限流器
- 背压控制

## 扩展性设计

### 水平扩展

- 无状态服务设计
- 负载均衡
- 自动扩缩容

### 插件机制

- 中间件链
- 拦截器
- 自定义处理器

## 相关资源

### 官方文档

- [Connect RPC](https://connectrpc.com/docs/go/getting-started)
- [Buf](https://buf.build/docs/)
- [sqlc](https://docs.sqlc.dev/)
- [golang-migrate](https://github.com/golang-migrate/migrate)

### 内部文档

- [新增服务开发指南](./新增服务开发指南.md)
- [API 设计规范](./API设计规范.md)
- [部署指南](./部署指南.md)